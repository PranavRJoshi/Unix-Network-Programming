Here are some of the definitions of the types and how they'll be used while: creating a semaphore, operating on a semaphore, and then conterolling the semaphore (which is usually removing the semaphore).

1.  Creating a semaphore:
      ->  Before the creation, similar to how the kernel maintains a data structure of a message queue (`msqid_ds`), there exists similar data structure: `semid_ds`, which has the following members: 

            /* includes */
            #include <sys/types.h>
            #include <sys/ipc.h>      /* defines the ipc_perm structure */

            struct semid_ds {
              struct ipc_perm sem_perm;     /* operation permission struct */
              struct sem      *sem_base;    /* ptr to first semaphore in set */
              ushort          sem_nsems;    /* number of semaphores in set */
              time_t          sem_otime;    /* time of last semop */
              time_t          sem_ctime;    /* last of last change */
            };

      ->  `ipc_perm`, similar to the one we've seen during message queue, contains the access permissions for this particular semaphore.
      ->  `sem` structure is an internal data structure used by the kernel to maintain the set of values for a given semaphore. The members are as follows:

            struct sem {
              ushort          semval;       /* semaphore value, nonnegative */
              short           sempid;       /* pid of last operation */
              ushort          semncnt;      /* number awaiting semval > cval */
              ushort          semzcnt;      /* number awaiting semval = 0 */
            };

      ->  Apart from the actual set of values for a semaphore, we see other three members: 
            - sempid: process ID of the process that did the last operation on the value.
            - semncnt: count of number of processes waiting for the value to increase.
            - semzcnt: count of number of processes waiting for the value to become zero.

      (Refer to Page 138 to view the picture of how the kernel stores this information)

      /* semget */

      ->  The function semget has the followig prototype:
            
            int semget (key_t key, int nsems, int semflag);

          Value returned by semget is the semaphore identifier, semid, or -1 if an error occured.

      ->  The parameters denotes the following meaning:
            - `key` is the semaphore key that is generated by using function like `ftok` or using hardcoded key.
            - `nsems` specifies the number of semaphores in the set. 
            - `semflag`, when creating a new semaphore, uses the `IPC_CREAT` flag. If we are not creating a new semaphore, but only accessing an existing set, we can specify the argument as zero. The `semflag` value is a combination of the constants as follows:
              
              |-------|------------|-------------------|
              |Numeric|  Symbolic  |    Description    |
              |-------|------------|-------------------|
              | 0400  | SEM_R      | Read by owner     |
              | 0200  | SEM_A      | Alter by owner    |
              | 0040  | SEM_R >> 3 | Read by group     |
              | 0020  | SEM_A >> 3 | Alter by group    |
              | 0004  | SEM_R >> 6 | Read by world     |
              | 0002  | SEM_A >> 6 | Alter by world    |
              |       | IPC_CREAT  | (See Section 3.8) |
              |       | IPC_EXCL   | (See Section 3.8) |
              |-------|------------|-------------------|   

      /* semop */

      ->  Once the semaphore has been created, operations are performed on one or more of the semaphore values in the set using the `semop` system call. The prototype is as follows:

            /* includes */
            #include <sys/types.h>
            #include <sys/ipc.h>
            #include <sys/sem.h>
            
            int semop (int semid, struct sembuf **opstr, unsigned int nops);

      ->  The `semid`, is the ID of the semaphore which is being operated on. 
      ->  The pointer `opstr` points to an array of `struct sembuf`, which has the following members:
            
            struct sembuf {
              ushort  sem_num;      /* semaphore number */
              short   sem_op;       /* semaphore operation */
              short   sem_flg;      /* operation flags */
            };
      
      ->  `nops` specifies the number of elements in the array of `sembuf` structures pointed to by `opstr`. Each element in the `sembuf` array specifies an operation for one particular semaphore value in the set.
      
      ->  Coming back to the `struct sembuf`:
            - `sem_num` specifies the particular semaphore value, which is zero for the first element, one for the second, and so on, up to `nsems - 1`, where nsems is the number of semaphore values in the set.
            - `sem_op` can be postive, zero, or negative, signifying the following operations:
                
                -- `sem_op` > 0: the value of `sem_val` is added to the semaphore's current value. This corresponds to the release of resouces that a semaphore controls.
                -- `sem_op` = 0: caller wants to wait until the semaphore's value becomes zero.
                -- `sem_op` < 0: caller wants to wait until the semaphore's value becomes greater than or equal to the absolute value of `sem_op`. This corresponds to the allocation of resources.

      ->  `sem_flg`, for instance, when it has `IPC_NOWAIT` flag set, tells the system we don't want to wait if the operation can't be completed. There is also the capability of having the system remember adjustment values for a given semaphore (used for edge cases like unterminated process). 

      ->  Upon successful call, the `semop` returns zero (0), or -1 if an error occured. (Check Page 141 of text to learn about an error in documentation of System V Release 2.)

      /* semctl */

      ->  The function prototype for the system call `semctl` is as follows:

            /* includes */
            #include <sys/types.h>
            #include <sys/ipc.h>
            #include <sys/sem.h>

            int semctl (int semid, int semnum, int cmd, union semun arg);

      ->  Some `cmd` that we will be using are:
            
            - IPC_RMID: remove a semaphore from the system.
            - GETVAL: fetch a specific semaphore value. (requires `semnum` argument to specify one member of semaphore set)
            - SETVAL: set a specific semaphore value. (requires `semnum` argument to specify one member of semaphore set)
      
      ->  The `semun` union has the following members:
      
            union semun {
              int               val;      /* used for SETVAL only */
              struct semid_ds   *buff;    /* used for IPC_STAT and IPC_SET */
              ushort            *array;   /* used for IPC_GETALL and IPC_SETALL */
            } arg;
